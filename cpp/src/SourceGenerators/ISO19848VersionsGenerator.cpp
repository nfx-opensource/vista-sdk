/**
 * @file ISO19848VersionsGenerator.cpp
 * @brief ISO 19848 version header generator tool
 * @details Generates ISO19848Versions.h (public API) and ISO19848VersionsExtensions.h (internal utilities) from
 * embedded ISO 19848 resource files
 */

#include <EmbeddedResources.h>

#include <nfx/string/StringBuilder.h>

#include <algorithm>
#include <cstdio>
#include <filesystem>
#include <fstream>
#include <string>
#include <vector>

using namespace dnv::vista::sdk;

static bool generateISO19848VersionHeader(
    const std::vector<std::string>& versions, const std::filesystem::path& outputPath, std::string_view sdkVersion )
{
    auto sb = nfx::string::StringBuilder( 8192 );

    sb.append( "/**\n" );
    sb.append( " * @file ISO19848Versions.h\n" );
    sb.append( " * @brief Type-safe enumeration of ISO 19848 versions\n" );
    sb.append( " * @details AUTO-GENERATED FILE - DO NOT EDIT - " );
    std::format_to(
        std::back_inserter( sb ), "Generated by: ISO19848VersionsGenerator (vista-sdk-cpp v{})\n", sdkVersion );
    sb.append( " */\n" );
    sb.append( "\n" );

    // Includes
    sb.append( "#pragma once\n\n" );
    sb.append( "#include <cstdint>\n" );
    sb.append( "#include <optional>\n" );
    sb.append( "#include <stdexcept>\n" );
    sb.append( "#include <string_view>\n\n" );
    sb.append( "namespace dnv::vista::sdk::transport\n" );
    sb.append( "{\n" );

    // Enum declaration
    sb.append( "\t/**\n" );
    sb.append( "\t * @brief ISO 19848 standard versions\n" );
    sb.append( "\t */\n" );
    sb.append( "\tenum class ISO19848Version : std::uint8_t\n" );
    sb.append( "\t{\n" );
    for( const auto& version : versions )
    {
        std::format_to( std::back_inserter( sb ), "\t\t{}, ///< ISO 19848:{}\n", version, version.substr( 1 ) );
    }
    sb.append( "\t};\n\n" );

    // ISO19848Versions namespace with conversion functions
    sb.append( "\t/**\n" );
    sb.append( "\t * @brief ISO 19848 version utilities\n" );
    sb.append( "\t */\n" );
    sb.append( "\tnamespace ISO19848Versions\n" );
    sb.append( "\t{\n" );

    // toString function
    sb.append( "\t\t/**\n" );
    sb.append( "\t\t * @brief Convert an ISO19848Version to its string representation\n" );
    sb.append( "\t\t * @param version The ISO19848Version enum value to convert\n" );
    sb.append( "\t\t * @return String representation of the version\n" );
    sb.append( "\t\t */\n" );
    sb.append( "\t\tconstexpr std::string_view toString( ISO19848Version version )\n" );
    sb.append( "\t\t{\n" );
    sb.append( "\t\t\tswitch ( version )\n" );
    sb.append( "\t\t\t{\n" );
    for( const auto& version : versions )
    {
        std::format_to( std::back_inserter( sb ), "\t\t\t\tcase ISO19848Version::{}:\n", version );
        std::format_to( std::back_inserter( sb ), "\t\t\t\t\treturn \"{}\";\n", version );
    }
    sb.append( "\t\t\t\tdefault:\n" );
    sb.append( "\t\t\t\t\tthrow std::invalid_argument{ \"Invalid ISO19848Version enum value\" };\n" );
    sb.append( "\t\t\t}\n" );
    sb.append( "\t\t}\n\n" );

    // fromString function with std::optional return
    sb.append( "\t\t/**\n" );
    sb.append( "\t\t * @brief Parse string to ISO19848Version\n" );
    sb.append( "\t\t * @param version String representation of the version (e.g., \"v2024\")\n" );
    sb.append( "\t\t * @return Optional containing ISO19848Version if successful, std::nullopt otherwise\n" );
    sb.append( "\t\t */\n" );
    sb.append(
        "\t\t[[nodiscard]] constexpr std::optional<ISO19848Version> fromString( std::string_view version ) "
        "noexcept\n" );
    sb.append( "\t\t{\n" );
    for( const auto& version : versions )
    {
        std::format_to( std::back_inserter( sb ), "\t\t\tif ( version == \"{}\" )\n", version );
        sb.append( "\t\t\t{\n" );
        std::format_to( std::back_inserter( sb ), "\t\t\t\treturn ISO19848Version::{};\n", version );
        sb.append( "\t\t\t}\n" );
    }
    sb.append( "\t\t\treturn std::nullopt;\n" );
    sb.append( "\t\t}\n" );

    // close namespaces
    sb.append( "\t} // namespace ISO19848Versions\n" );
    sb.append( "} // namespace dnv::vista::sdk::transport\n" );

    std::ofstream outputFile( outputPath, std::ios::binary );
    if( !outputFile )
    {
        fprintf( stderr, "Failed to open output file: %s\n", outputPath.string().c_str() );
        return false;
    }

    outputFile.write( sb.data(), static_cast<std::streamsize>( sb.size() ) );

    if( !outputFile )
    {
        fprintf( stderr, "Failed to write to output file: %s\n", outputPath.string().c_str() );
        return false;
    }

    return true;
}

static bool generateISO19848VersionExtensionsHeader(
    const std::vector<std::string>& versions, const std::filesystem::path& outputPath, std::string_view sdkVersion )
{
    auto sb = nfx::string::StringBuilder( 8192 );

    sb.append( "/**\n" );
    sb.append( " * @file ISO19848VersionsExtensions.h\n" );
    sb.append( " * @brief Internal ISO 19848 version utilities for SDK implementation\n" );
    sb.append( " * @details AUTO-GENERATED FILE - DO NOT EDIT - " );
    std::format_to(
        std::back_inserter( sb ), "Generated by: ISO19848VersionsGenerator (vista-sdk-cpp v{})\n", sdkVersion );
    sb.append( " */\n" );
    sb.append( "\n" );

    // Includes
    sb.append( "#pragma once\n\n" );
    sb.append( "#include \"dnv/vista/sdk/transport/ISO19848Versions.h\"\n\n" );
    sb.append( "#include <array>\n" );
    sb.append( "#include <string_view>\n\n" );
    sb.append( "namespace dnv::vista::sdk::transport\n" );
    sb.append( "{\n" );

    // ISO19848Versions namespace
    sb.append( "\t/**\n" );
    sb.append( "\t * @brief Internal ISO 19848 version utilities\n" );
    sb.append( "\t * @note For internal SDK use only\n" );
    sb.append( "\t */\n" );
    sb.append( "\tnamespace ISO19848Versions\n" );
    sb.append( "\t{\n" );

    // All versions array
    sb.append( "\t\t/**\n" );
    sb.append( "\t\t * @brief Array of all ISO 19848 versions enum values\n" );
    sb.append( "\t\t * @return Array containing all ISO 19848 version enum values\n" );
    sb.append( "\t\t */\n" );
    std::format_to(
        std::back_inserter( sb ), "\t\tconstexpr std::array<ISO19848Version, {}> all()\n", versions.size() );
    sb.append( "\t\t{\n" );
    sb.append( "\t\t\treturn {\n" );
    for( size_t i = 0; i < versions.size(); ++i )
    {
        std::format_to( std::back_inserter( sb ), "\t\t\t\tISO19848Version::{},\n", versions[i] );
    }
    sb.append( "\t\t\t};\n" );
    sb.append( "\t\t}\n\n" );

    // latest function
    sb.append( "\t\t/**\n" );
    sb.append( "\t\t * @brief Get the latest available ISO 19848 version\n" );
    sb.append( "\t\t * @return The latest ISO 19848 version\n" );
    sb.append( "\t\t */\n" );
    sb.append( "\t\tconstexpr ISO19848Version latest() noexcept\n" );
    sb.append( "\t\t{\n" );
    sb.append( "\t\t\tconstexpr auto versions = all();\n" );
    sb.append( "\t\t\treturn versions.back();\n" );
    sb.append( "\t\t}\n" );

    // close namespaces
    sb.append( "\t} // namespace ISO19848Versions\n" );
    sb.append( "} // namespace dnv::vista::sdk::transport\n" );

    std::ofstream outputFile( outputPath, std::ios::binary );
    if( !outputFile )
    {
        fprintf( stderr, "Failed to open output file: %s\n", outputPath.string().c_str() );
        return false;
    }

    outputFile.write( sb.data(), static_cast<std::streamsize>( sb.size() ) );

    if( !outputFile )
    {
        fprintf( stderr, "Failed to write to output file: %s\n", outputPath.string().c_str() );
        return false;
    }

    return true;
}

int main( int argc, char* argv[] )
{
    if( argc < 4 )
    {
        fprintf(
            stderr, "Usage: ISO19848VersionsGenerator <public_header_path> <extensions_header_path> <sdk_version>\n" );
        return 1;
    }

    std::filesystem::path iso19848VersionHeaderPath = argv[1];
    std::filesystem::path iso19848VersionExtensionsPath = argv[2];
    std::string_view sdkVersion = argv[3];

    printf( "Loading ISO 19848 versions from embedded resources...\n" );

    auto versions = EmbeddedResources::iso19848Versions();

    if( versions.empty() )
    {
        fprintf( stderr, "No ISO 19848 versions found!\n" );
        return 1;
    }

    printf( "Found %zu ISO 19848 versions:\n", versions.size() );
    for( const auto& version : versions )
    {
        printf( "  - %s\n", version.c_str() );
    }

    printf( "Generating public header: %s\n", iso19848VersionHeaderPath.string().c_str() );

    if( !generateISO19848VersionHeader( versions, iso19848VersionHeaderPath, sdkVersion ) )
    {
        return 1;
    }

    printf( "Generating extensions header: %s\n", iso19848VersionExtensionsPath.string().c_str() );

    if( !generateISO19848VersionExtensionsHeader( versions, iso19848VersionExtensionsPath, sdkVersion ) )
    {
        return 1;
    }

    return 0;
}
